{% extends "base.html" %}
{% block css %}
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
     integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
     crossorigin=""/>
<style>
    .legend {
        background: white;
        padding: 8px;
        line-height: 1.5;
        border-radius: 5px;
        box-shadow: 0 0 10px rgba(0,0,0,0.3);
        font-size: 14px;
        color: black;
    }
    .legend i {
        width: 12px;
        height: 12px;
        display: inline-block;
        margin-right: 6px;
        border-radius: 50%;
    }
    #filter-container {
        text-align: center;
        margin-top: 10px;
    }
    .filter-checkbox {
        margin: 0 10px;
    }
</style>
{% endblock %}

{% block body %}
<div id="map" style="width: 100%; height: 600px;"></div>

<div id="filter-container">
    <input type="checkbox" class="filter-checkbox" id="filter-routers-only"> Show Routers Only
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
     integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
     crossorigin=""></script>

<script>
    var map = L.map('map');
    L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
    }).addTo(map);

    var markers = {};
    var nodeIndex = {}; // node.id -> [lat, lng]
    var bounds = L.latLngBounds();
    var channels = new Set();

    var nodes = [
    {% for node in nodes %}
    {
        lat: {{ (node.last_lat / 10**7)|round(7) }},
        long: {{ (node.last_long / 10**7)|round(7) if node.last_long is not none else "null" }},
        long_name: {{ (node.long_name or "") | tojson }},
        short_name: {{ (node.short_name or "") | tojson }},
        channel: {{ (node.channel or "") | tojson }},
        hw_model: {{ (node.hw_model or "") | tojson }},
        role: {{ (node.role or "") | tojson }},
        last_update: {{ node.last_update | default("", true) | tojson }},
        firmware: {{ (node.firmware or "") | tojson }},
        id: {{ (node.node_id or "") | tojson }},
        isRouter: "{{ 'router' in node.role.lower() }}"
    }{{ "," if not loop.last else "" }}
    {% endfor %}
    ];

    function timeAgo(date) {
        var now = new Date();
        var diff = now - new Date(date);
        var seconds = Math.floor(diff / 1000);
        var minutes = Math.floor(seconds / 60);
        var hours = Math.floor(minutes / 60);
        var days = Math.floor(hours / 24);

        if (days > 0) return days + "d";
        if (hours > 0) return hours + "h";
        if (minutes > 0) return minutes + "m";
        return seconds + "s";
    }

    const palette = [
        "#e6194b","#4363d8","#f58231","#911eb4","#46f0f0","#f032e6","#bcf60c","#fabebe",
        "#008080","#e6beff","#9a6324","#fffac8","#800000","#aaffc3","#808000","#ffd8b1","#000075","#808080"
    ];
    const colorMap = new Map();
    let nextColorIndex = 0;
    function hashToColor(str) {
        if (colorMap.has(str)) return colorMap.get(str);
        const color = palette[nextColorIndex % palette.length];
        colorMap.set(str, color);
        nextColorIndex++;
        return color;
    }

    // Plot nodes
    nodes.forEach(function(node) {
        if (node.lat !== null && node.long !== null) {
            let category = node.channel;
            let isRouter = node.isRouter === "True";
            channels.add(category);

            let color = hashToColor(category);
            let markerOptions = {
                radius: isRouter ? 9 : 7,
                color: "white",
                fillColor: color,
                fillOpacity: 1,
                weight: 0.7,
            };

            var popupContent = `
                <b><a href="/packet_list/${node.id}">${node.long_name}</a> (${node.short_name})</b><br>
                <b>Channel:</b> ${node.channel}<br>
                <b>Model:</b> ${node.hw_model}<br>
                <b>Role:</b> ${node.role}<br>
            `;
            if (node.last_update) popupContent += `<b>Last seen:</b> ${timeAgo(node.last_update)}<br>`;
            if (node.firmware) popupContent += `<b>Firmware:</b> ${node.firmware}<br>`;

            var marker = L.circleMarker([node.lat, node.long], markerOptions).bindPopup(popupContent);
            marker.addTo(map);

            if (!markers[category]) markers[category] = [];
            markers[category].push({ marker, isRouter });

            nodeIndex[node.id] = [node.lat, node.long];
            bounds.extend(marker.getLatLng());
        }
    });

    // Fit to configured bounds
    var bayAreaBounds = [
        [{{ site_config["site"]["map_top_left_lat"] }}, {{ site_config["site"]["map_top_left_lon"] }}],
        [{{ site_config["site"]["map_bottom_right_lat"] }}, {{ site_config["site"]["map_bottom_right_lon"] }}]
    ];
    map.fitBounds(bayAreaBounds);

    // Create channel filters
    let filterContainer = document.getElementById("filter-container");
    channels.forEach(channel => {
        let filterId = `filter-${channel.replace(/\s+/g, '-').toLowerCase()}`;
        let color = hashToColor(channel);
        let filterHtml = `
            <label style="color:${color};">
                <input type="checkbox" class="filter-checkbox" id="${filterId}" checked> ${channel}
            </label>
        `;
        filterContainer.innerHTML += filterHtml;
    });

    function updateMarkers() {
        let showRoutersOnly = document.getElementById("filter-routers-only").checked;
        channels.forEach(channel => {
            let filterId = `filter-${channel.replace(/\s+/g, '-').toLowerCase()}`;
            let isChecked = document.getElementById(filterId).checked;
            markers[channel].forEach(obj => {
                let shouldShow = isChecked && (!showRoutersOnly || obj.isRouter);
                shouldShow ? map.addLayer(obj.marker) : map.removeLayer(obj.marker);
            });
        });
    }

    document.querySelectorAll(".filter-checkbox").forEach(input => {
        input.addEventListener("change", updateMarkers);
    });

    // --- Lazy load edges on node click ---
    var edgeLayer = L.layerGroup().addTo(map); // initially empty
    var edgesData = null;

    function loadEdges(callback) {
        if (edgesData) {
            callback(edgesData);
        } else {
            fetch('/api/edges')
                .then(res => res.json())
                .then(data => {
                    edgesData = data.edges;
                    callback(edgesData);
                })
                .catch(err => console.error("Error loading edges:", err));
        }
    }

    function onNodeClick(node) {
        loadEdges(function(edges) {
            edgeLayer.clearLayers(); // remove previous edges

            edges.forEach(edge => {
                if (edge.from === node.id || edge.to === node.id) {
                    let from = nodeIndex[edge.from];
                    let to = nodeIndex[edge.to];
                    if (from && to) {
                        let poly = L.polyline([from, to], {
                            color: edge.type === "neighbor" ? "red" : "blue",
                            weight: 2,
                            opacity: 1,
                            dashArray: edge.type === "traceroute" ? "5,5" : null
                        }).addTo(edgeLayer);

                        poly.bringToBack();
                        poly.setStyle({opacity: 1}); // highlight edge immediately
                    }
                }
            });
        });
    }

    // Attach click events to nodes
    nodes.forEach(node => {
        if (node.lat !== null && node.long !== null) {
            let marker = markers[node.channel].find(obj =>
                obj.marker.getLatLng().lat === node.lat &&
                obj.marker.getLatLng().lng === node.long
            ).marker;

            marker.on('click', () => onNodeClick(node));
        }
    });
</script>
{% endblock %}
